# Create your views here.
import os
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, JsonResponse
from django.shortcuts import render
from django.views.decorators.csrf import ensure_csrf_cookie
from django.core.exceptions import ObjectDoesNotExist
from django.core import serializers
from .models import *
import pandas
from collections import defaultdict
import logging
from numpy import asscalar
import json
logger = logging.getLogger("eeg.views")

WINDOW_LENGTH = 30 # seconds
RECORDING_DIRECTORY = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'recordings')
test = 'hello'

def index(request):
    return HttpResponse("Welcome to the EEG Project.")

@login_required
@ensure_csrf_cookie
def expert(request):
    return render(request, 'viewer/expert.html', {'test': test})

@login_required
@ensure_csrf_cookie
def novice(request):
    return render(request, 'viewer/novice.html', {'test': test})

# Create your views here.
@login_required
def getEEGData(request, recording, start_time, window_length):
    """Loads one window of EEG data from CSV file. This data is packaged into
    a JSON response (80-110kb). 
    For this to work, the CSV must have been generated by edf_extract, which 
    pares it down the minimal number of channels and down samples it to consume 
    a very minimal amount of hard disk space (around 40-90mb for an 8 hour recording).

    This method could be optimized, but for our purposes (analyzing sleep spindles
    in EEG) this is more than good enough.
    see also: annotator.js, eeg_processing/signal_processing/edf_extract.py
    """
    start_time = int(start_time)
    window_length = int(window_length) # seconds of EEG recording per window
    csv_fp = os.path.join(os.path.dirname(os.path.abspath(__file__)), 
        os.path.join(RECORDING_DIRECTORY, recording+'.csv'))
    sample_rate = int(recording[recording.rfind('_')+1:])
    skip_samples = sample_rate * start_time # number of CSV rows to skip
    num_samples_to_send = sample_rate * window_length
    # note, this could be improved by writing a pandas parser for EDF, or replacing Pandas with an EDF parser
    df = pandas.read_csv(csv_fp, skiprows=xrange(1, skip_samples), nrows=num_samples_to_send)
    response = df.to_dict(orient='list')
    response_columns = df.columns.values.tolist()

    # check for empty dataframe (occurs at the end of the file)
    if not response[response_columns[0]]:
        return JsonResponse({}) # return an empty response if past file's end

    # dict loses the original order, so send column list for reconstruction purposes
    response['ordered_channels'] = [col for col in response_columns if not col.find('time')>-1]
    return JsonResponse(response)

@login_required
def expertaddfeature(request):
    """called whenever a user highlights a spindle or a k-complex, this method
    stores the feature selection in the database
    """
    if request.method == 'POST':
        # grab the annotation from the request object 
        feature_type = request.POST['feature_type']
        channel = request.POST['channel']
        time_start = request.POST['time_start']
        time_end = request.POST['time_end']
        certainty = request.POST['certainty_score']
        annotator_username = request.user.get_username()
        recording_name = request.POST['recording_name']
        # load this window in the database, or create one if this window has never been
        # annotated before. 
        annotator, created = Annotator.objects.get_or_create(username=annotator_username)
        recording, created = Recording.objects.get_or_create(name=recording_name)
        print "created new annotator: {}".format(created)

        # save the annotation to the database
        annotation_feature = Feature(
            recording=recording, feature_type=feature_type, channel=channel, 
            start=time_start, end=time_end, certainty=1.0, annotator=annotator)
        annotation_feature.save()
        return HttpResponse("", status=200)
    else:
        return HttpResponseBadRequest("This view accepts POST requests only")

@login_required
def deleteFeature(request):
    """called whenever a user double clicks on a highlighted section to remove
    it, this method deletes that highlight from the database
    """
    print 'called expert_delete_feature'
    if request.method == 'POST':
        # grab the annotation from the request object 
        time_start = request.POST['time_start']
        time_end = request.POST['time_end']
        channel = request.POST['channel']
        annotator_username = request.user.get_username()
        recording_name = request.POST['recording_name']
        
        annotator = Annotator.objects.get(username=annotator_username)
        recording = Recording.objects.get(name=recording_name)

        # delete the annotation from the database
        annotation_feature = Feature.objects.get(
            start=time_start,end=time_end,channel=channel,annotator=annotator,recording=recording)
        annotation_feature.delete()
        return HttpResponse("")
    else:
        return HttpResponseBadRequest("Use post")

@login_required
def getAnnotations(request, recording_name, window_start, window_end):
    annotator, created = Annotator.objects.get_or_create(username=request.user.get_username())
    recording, created = Recording.objects.get_or_create(name=recording_name)
    # Django query sets use lazy evaulation, using list forces them to evaluate
    features = list(Feature.objects.filter(recording=recording, annotator=annotator).filter(start__gte=window_start).filter(end__lte=window_end))
    feature_list = [ob.as_dict() for ob in features]

    data = {'features': feature_list}
    return JsonResponse(data)